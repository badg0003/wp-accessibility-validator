/**
 * DOM manipulation utilities for the accessibility validator.
 *
 * Provides helper functions for interacting with the block editor UI,
 * including focusing blocks, opening the results panel, highlighting
 * violation cards, and creating off-screen DOM containers for scanning.
 *
 * @package WPAccessibilityValidator
 */

import type {
	WPBlockEditorStore,
	WPEditPostStore,
	WPEditorStore,
} from '../types';
import { PANEL_STORE_ID, DATA_ATTRIBUTES, HIGHLIGHT_DURATION } from '../constants';
import { dispatch, select } from '@wordpress/data';

/**
 * Focuses a block in the editor by its client ID.
 *
 * Selects the block in the core/block-editor store so that it becomes the
 * active block in the editor canvas. If no client ID is provided, the
 * function exits early.
 *
 * @since 1.0.0
 *
 * @param {string} [clientId] The client ID of the block to focus.
 */
export const focusBlockById = (clientId?: string): void => {
	if (!clientId) {
		return;
	}

	const blockStore = dispatch('core/block-editor') as Partial<WPBlockEditorStore>;
	blockStore?.selectBlock?.(clientId);
};

/**
 * Opens the accessibility results panel in the editor sidebar.
 *
 * Ensures the main document sidebar is visible and then opens the custom
 * panel registered by this plugin if it is not already open.
 *
 * @since 1.0.0
 */
export const openResultsPanel = (): void => {
	const editPostDispatch = dispatch('core/edit-post') as Partial<WPEditPostStore>;
	const editorStore = select('core/editor') as Partial<WPEditorStore>;

	editPostDispatch?.openGeneralSidebar?.('edit-post/document');

	if (
		editPostDispatch?.toggleEditorPanelOpened &&
		editorStore?.isEditorPanelOpened &&
		!editorStore.isEditorPanelOpened(PANEL_STORE_ID)
	) {
		editPostDispatch.toggleEditorPanelOpened(PANEL_STORE_ID);
	}
};

/**
 * Highlights violation elements in the panel and scrolls them into view.
 *
 * Applies a temporary highlight class to each card that matches the provided
 * violation IDs and scrolls it into the center of the viewport. If the DOM
 * is not available (e.g. in a non-browser context), the function exits early.
 *
 * @since 1.0.0
 *
 * @param {string[]} violationIds Array of violation IDs to highlight.
 */
export const highlightViolations = (violationIds: string[]): void => {
	if (violationIds.length === 0 || typeof document === 'undefined') {
		return;
	}

	// Slight delay to allow panel to render before focusing
	window.requestAnimationFrame(() => {
		violationIds.forEach((violationId: string) => {
			const element = document.querySelector(
				`[${DATA_ATTRIBUTES.violationId}="${violationId}"]`
			) as HTMLElement | null;

			if (element) {
				element.classList.add('wpav-highlight');
				element.scrollIntoView({
					block: 'center',
					behavior: 'smooth',
				});

				window.setTimeout(() => {
					element.classList.remove('wpav-highlight');
				}, HIGHLIGHT_DURATION);
			}
		});
	});
};

/**
 * Creates a visually hidden element for accessibility scanning.
 *
 * The element is positioned off-screen so it remains available to scanning
 * tools (such as axe-core) while remaining invisible to users. If the DOM
 * is not available, a no-op cleanup function is returned.
 *
 * Note: The provided HTML is inserted directly as innerHTML and is assumed
 * to be trusted content generated by the editor and plugin. Do not pass
 * arbitrary user input into this function without additional sanitization.
 *
 * @since 1.0.0
 *
 * @param {string} html The HTML content to render in the element.
 * @return {Function} A cleanup function to remove the element.
 */
export const createScanElement = (html: string): (() => void) => {
	if (typeof document === 'undefined' || !document.body) {
		return () => {};
	}

	const element = document.createElement('div');

	// Position off-screen instead of using the hidden attribute.
	// This makes it accessible to axe-core while invisible to users.
	Object.assign(element.style, {
		position: 'absolute',
		left: '-10000px',
		top: 'auto',
		width: '1px',
		height: '1px',
		overflow: 'hidden',
	});

	// Insert the provided HTML directly. Content is assumed to be trusted.
	element.innerHTML = html;

	document.body.appendChild(element);

	// Return cleanup function.
	return () => {
		if (element.parentNode) {
			element.parentNode.removeChild(element);
		}
	};
};
